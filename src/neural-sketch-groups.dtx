% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%  neural-sketch-groups.dtx
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ <<<
% \iffalse
%<*driver>
\documentclass{ltxdoc}
\EnableCrossrefs
\CodelineIndex
\RecordChanges

\begin{document}
\DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi

\ProvidesFile{neural-sketch-groups.dtx}%
[2025/01/22 v0.1 neural-sketch-groups]

% \title{neural-sketch-groups.sty\\
%        Grouping support for neural-sketch}
% \author{Vincenzo Buono}
% \date{\today}
% \maketitle
%
% \StopEventually{}
%
% implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ <<<
%<*package>
%    \begin{macrocode}
\ExplSyntaxOn

% ---------------------------------------------------------------------
% 1) Global Data Structures
% ---------------------------------------------------------------------
\tl_set:Nn \l_nsk_group_refnode_id_tl {__nsk_phantom_refnode}
\prop_new:N \l_nsk_group_unknown_prop

%-----------------------------------------------------------
% parse pos
%-----------------------------------------------------------
\cs_new_protected_nopar:Npn \nsk__group_parse_pos_value:V #1
{

	% 1) Store the userâ€™s "pos={...}" string in a variable
	\tl_set:Nx \l_nsk_group_pos_tl { #1 }

	% % 2) Default anchor is "center"
	\tl_set:Nn \l_nsk_group_anchor_tl { center }

	% 3) Split #1 at the '=' sign into a sequence \l_tmpa_seq
	%    If the user wrote "right=1cm of A", item 1 is "right"
	%    and item 2 is "1cm of A". If there's no '=', there's
	%    only one item, so you can skip or do fallback logic.
	\seq_set_split:Nnx \l_tmpa_seq {=}{#1}
	\seq_show:N \l_tmpa_seq

	% 4) Check if there's at least two items (the part before '=' plus after '=')
	\int_compare:nNnT { \seq_count:N \l_tmpa_seq } > {1}
		{
			% The first item is "right", "left", etc.
			\tl_set:Nx \l_tmpa_tl { \seq_item:Nn\l_tmpa_seq {1} }
			\tl_trim_spaces:N \l_tmpa_tl

			% % Compare it to known directions to pick an anchor
			\tl_if_eq:VnT \l_tmpa_tl {right} { \tl_set:Nn \l_nsk_group_anchor_tl { west } }
			\tl_if_eq:VnT \l_tmpa_tl {left}  { \tl_set:Nn \l_nsk_group_anchor_tl { east } }
			\tl_if_eq:VnT \l_tmpa_tl {above} { \tl_set:Nn \l_nsk_group_anchor_tl { south } }
			\tl_if_eq:VnT \l_tmpa_tl {below} { \tl_set:Nn \l_nsk_group_anchor_tl { north } }
		}
}

%-----------------------------------------------------------
% Group
% logical grouping
%-----------------------------------------------------------
\keys_define:nn {nsk / group}
{
	% bounds id ------------------------------------------------
	bounds-name .tl_set:N = \l_nsk_group_bounds_name_tl,
	bounds-name .initial:n = {__nsk_container_bounds},
	bounds-name .default:n = {__nsk_container_bounds},

	% natural positioning using positioning library
	pos .code:n =
		{
			\nsk__group_parse_pos_value:V {#1}
			% \tl_set:Nn \l_nsk_group_pos_tl {#1}
		},
	pos .initial:n = { },
	pos .default:n = { },

	shift-x .fp_set:N = \l_nsk_group_x_fp,
	shift-x .initial:n = {0},
	shift-x .default:n = {0},

	shift-y .fp_set:N = \l_nsk_group_y_fp,
	shift-y .initial:n = {0},
	shift-y .default:n = {0},

	rotate .fp_set:N = \l_nsk_group_rotate_fp,
	rotate .initial:n = {0},
	rotate .default:n = {0},

	scale .fp_set:N = \l_nsk_group_scale_fp,
	scale .initial:n = {1},
	scale .default:n = {1},

	% todo: this requires proper expansion
	% Optional "group-style" pass-through
	group-style .code:n =
		{
			\tl_set:Nn \l_nsk_group_extra_style_tl {#1}
		},
	group-style .initial:n = {},
	group-style .default:n = {},

	% forward unknown props to scope
	unknown .code:n =
		{
			% Store unknown key in the property list, using the content of \l_keys_key_tl as a string
			\prop_put:Nxx \l_nsk_group_unknown_prop
			{ \tl_use:N \l_keys_key_tl }
			{ #1 }
		},
}



%-----------------------------------------------------------------
% 3) Internal: build the final TikZ style as a comma-separated list
%    We'll store it in \l_tmpa_tl.
%-----------------------------------------------------------------
\cs_new_protected_nopar:Npn \nsk__build_group_style:
{
	% We'll create \l_tmpa_tl anew each time
	\tl_clear_new:N \l_tmpa_tl


	\tl_put_right:Nx \l_tmpa_tl
	{ local\space bounding\space box=\tl_use:N \l_nsk_group_bounds_name_tl, }


	% {x,y} pos ------------------------------------------------
	\tl_if_blank:VTF \l_nsk_group_pos_tl
	{
		% shift=(...)
		\tl_put_right:Nx \l_tmpa_tl
		{ shift={(\fp_use:N \l_nsk_group_x_fp,\fp_use:N \l_nsk_group_y_fp)}, }
	}
	{
		% -- pos is given => shift to reference phantom node
		\tl_put_right:Nx \l_tmpa_tl
		{ shift={(\tl_use:N \l_nsk_group_refnode_id_tl)}, }
	}

	% rotate=...
	\tl_put_right:Nx \l_tmpa_tl { rotate=\fp_use:N \l_nsk_group_rotate_fp, }

	% scale=...
	\tl_if_eq:nnF {\fp_to_decimal:N \l_nsk_group_scale_fp}{1.0}
	{ \tl_put_right:Nx \l_tmpa_tl { scale=\fp_use:N \l_nsk_group_scale_fp, } }

	% anchor=
	% for relative naural positionig/alignment
	\tl_put_right:Nx \l_tmpa_tl
	{ anchor=\tl_use:N \l_nsk_group_anchor_tl, }

	% user-supplied style pass-through
	\tl_if_empty:VTF \l_nsk_group_extra_style_tl
	{ % do nothing if empty
	}
	{
		\tl_put_right:Nx \l_tmpa_tl { \l_nsk_group_extra_style_tl, }
	}

	% forward unknown keys as-is
	\prop_map_inline:Nn \l_nsk_group_unknown_prop
	{
		\tl_put_right:Nn \l_tmpa_tl
		{
			##1 = ##2,
		}
	}
}

%-----------------------------------------------------------------
% 4) Internal: draw the scope with the built style
%    #1 -> the style token list (passed by value)
%    #2 -> user content
%-----------------------------------------------------------------
\cs_new_protected_nopar:Npn \nsk__draw_group_scope_aux:nnn #1 #2 #3
{

	% phantom reference node for natural positioning
	\tl_if_blank:VF \l_nsk_group_pos_tl
	{
		\node[#3, anchor=center] (\l_nsk_group_refnode_id_tl) {};
	}

	\begin{scope}[#1]
		#2
	\end{scope}

	% FIXME: delete me
	\tl_if_blank:VF \l_nsk_group_pos_tl
	{
		\fill[green] (\l_nsk_group_refnode_id_tl) circle (1mm);

		\draw[green,thick]
		(\l_nsk_group_bounds_name_tl.south\space west) rectangle
		(\l_nsk_group_bounds_name_tl.north\space east);
	}

}
\cs_generate_variant:Nn \nsk__draw_group_scope_aux:nnn { Vnx }
% ^ so we can pass \l_tmpa_tl by value (like :Vn)

%-----------------------------------------------------------------
% 5) Public macro \nskGroup
%-----------------------------------------------------------------
\NewDocumentCommand \nskGroup { O{} +m }
{
	\group_begin:

	% (a) Parse user-supplied keys
	\keys_set:nn {nsk / group} {#1}

	% (b) Build a comma-separated style in \l_tmpa_tl
	\nsk__build_group_style:

	% (c) Draw the scope, passing the style "by value"
	\nsk__draw_group_scope_aux:Vnx \l_tmpa_tl {#2} \l_nsk_group_pos_tl

	\group_end:
}

\ExplSyntaxOff
%\end{macrocode}
%</package>

\endinput
