
\ExplSyntaxOn

% ---------------------------------------------------------------------
% 1) Global Data Structures
% ---------------------------------------------------------------------

% A counter to generate unique path names.
\int_new:N \g__nsk_connect_counter_int

% A sequence storing bridging info for each path:
% Each item is a comma list:
%   pathName, arrowStyle, color, bridgingStyle, bridgingPath,
%   bridgingSpan, bridgingGap
\seq_new:N \g__nsk_bridging_info_seq


% ---------------------------------------------------------------------
% 2) Storing One Connect Item
% ---------------------------------------------------------------------
% (path name, arrow style, color, bridging style, bridging path,
%  bridging span, bridging gap)
\cs_new_protected_nopar:Npn \__nsk_connect_store_item:nnnnnnn #1#2#3#4#5#6#7
{
	% We'll build a single token list item, then push it into
	% the bridging sequence.
	\tl_clear_new:N \l__nsk_storeitem_tl

	% Insert #1..#7 by expansion (x), forming a comma list:
	\exp_args:NNx \tl_put_right:Nn \l__nsk_storeitem_tl
	{ #1, { #2 }, #3, #4, #5, #6, #7 }

	% Now append that item to the bridging sequence:
	\seq_gput_right:No \g__nsk_bridging_info_seq \l__nsk_storeitem_tl

	% Debug lines (currently commented out):
	\seq_show:N \g__nsk_bridging_info_seq
	\tl_show:N  \l__nsk_storeitem_tl
}


% ---------------------------------------------------------------------
% 3) Key-Value Setup for \nskConnect
% ---------------------------------------------------------------------

% A boolean to track bridging = true/false
\bool_new:N \l__nsk_connect_bridging_bool

\keys_define:nn { nsk / connect }
{
	from .tl_set:N           = \l_nsk_connect_from_tl,
	from .value_required:n   = true,

	to .tl_set:N             = \l_nsk_connect_to_tl,
	to .value_required:n     = true,

	route .tl_set:N          = \l_nsk_connect_route_tl,
	route .initial:n         = { -- },

	bridging .choice:,
	bridging / true  .code:n = { \bool_set_true:N  \l__nsk_connect_bridging_bool },
	bridging / false .code:n = { \bool_set_false:N \l__nsk_connect_bridging_bool },
	bridging .initial:n      = { false },

	bridging-style .choice:,
	bridging-style / over  .code:n  = { \tl_set:Nn \l_nsk_connect_bridging_style_tl { over } },
	bridging-style / under .code:n  = { \tl_set:Nn \l_nsk_connect_bridging_style_tl { under } },
	bridging-style .initial:n       = { under },
	bridging-style .default:n       = { under },

	bridging-path .tl_set:N         = \l_nsk_connect_bridging_path_tl,
	bridging-path .initial:n        = { arc },

	bridging-span .tl_set:N         = \l_nsk_connect_bridging_span_tl,
	bridging-span .initial:n        = { 8pt },

	bridging-gap .tl_set:N          = \l_nsk_connect_bridging_gap_tl,
	bridging-gap .initial:n         = { 4pt },

	arrow-style .tl_set:N           = \l_nsk_connect_arrow_style_tl,
	arrow-style .initial:n          = {ultra\space thick, >=Triangle},

	color .tl_set:N                 = \l_nsk_connect_color_tl,
	color .initial:n                = { black },

	% bend-routing ---------------------------------------------
	bend .choice:,
	bend / none  .code:n = { \bool_set_false:N \l__nsk_connect_bend_bool },
	bend / true  .code:n = { \bool_set_true:N  \l__nsk_connect_bend_bool },
	bend .initial:n = {none},

	% 2) A “bend-direction” key
	bend-direction .choice:,
	bend-direction / up    .code:n = { \tl_set:Nn \l__nsk_connect_bend_direction_tl { up } },
	bend-direction / down  .code:n = { \tl_set:Nn \l__nsk_connect_bend_direction_tl { down } },
	bend-direction / left  .code:n = { \tl_set:Nn \l__nsk_connect_bend_direction_tl { left } },
	bend-direction / right .code:n = { \tl_set:Nn \l__nsk_connect_bend_direction_tl { right } },
	bend-direction .initial:n = { up }, % e.g. default is "up"

	% 3) “bend-distance” key for how far to extend
	bend-distance .dim_set:N = \l__nsk_connect_bend_amount_dim,
	bend-distance .initial:n  = {1cm},
	bend-distance .default:n  = {1cm},

	% 4) A convenience key that allows user to write something like
	%    bend-route = { up 1cm } or just up 1cm
	bend-route .code:n =
		{
			% parse the #1 string, e.g. "up 1cm"
			\__nsk_parse_bend_route:n {#1}
		},

}


% ---------------------------------------------------------------------
% 4) Connect Drawing Helpers
% ---------------------------------------------------------------------

% Immediate draw if bridging is false:
%   \nsk__draw_connect:VV
% #1 => arrow-style, #2 => color
\cs_new_protected_nopar:Npn \nsk__draw_connect:VV #1#2
{
	% if \l__nsk_connect_bend_bool is true, generate route accordingly:
	\bool_if:NT \l__nsk_connect_bend_bool
	{
		\__nsk_connect_generate_bend_route:
	}
	\expandafter\draw\expandafter[
		#1,
		draw=#2
	]
	(\l_nsk_connect_from_tl)
	\l_nsk_connect_route_tl
	(\l_nsk_connect_to_tl);
}


% Save a soft path if bridging is true:
%   \nsk__spath_save:V
% #1 => path name (by value)
\cs_new_protected_nopar:Npn \nsk__spath_save:V #1
{
	\iow_term:x {
		=save=>#1
		-from=\tl_use:N \l_nsk_connect_from_tl
		-route=\tl_use:N \l_nsk_connect_route_tl
		-to=\tl_use:N \l_nsk_connect_to_tl
	}

	% Just a simplified path from->to:
	\path[
		spath/save\space global=#1
	]
	(\tl_use:N \l_nsk_connect_from_tl)
	\tl_use:N \l_nsk_connect_route_tl
	(\tl_use:N \l_nsk_connect_to_tl);
}


% ---------------------------------------------------------------------
% 5) Public \nskConnect Macro
% ---------------------------------------------------------------------
\NewDocumentCommand \nskConnect { O{} }
{
	\group_begin:

	% (a) parse user keys for "nsk/connect"
	\keys_set:nn { nsk / connect } { #1 }

	% (b) increment the global path counter
	\int_gincr:N \g__nsk_connect_counter_int

	% (c) build a default path name e.g. "path1"
	\tl_set:Nx \l_tmpa_tl { path\int_use:N \g__nsk_connect_counter_int }

	% (d) bridging check
	\bool_if:NTF \l__nsk_connect_bridging_bool
	{
		% bridging == true => store path with spath
		\nsk__spath_save:V \l_tmpa_tl

		% then store bridging data for later
		\__nsk_connect_store_item:nnnnnnn
		{
			\tl_use:N \l_tmpa_tl
		}
		{ \l_nsk_connect_arrow_style_tl      }
		{ \l_nsk_connect_color_tl            }
		{ \l_nsk_connect_bridging_style_tl   }
		{ \l_nsk_connect_bridging_path_tl    }
		{ \l_nsk_connect_bridging_span_tl    }
		{ \l_nsk_connect_bridging_gap_tl     }

		% debugging lines if needed:
		% \tl_show:N \l_tmpa_tl
		% \tl_show:N \l_nsk_connect_arrow_style_tl
		% ...
	}
	{
		% bridging == false => draw it now
		\nsk__draw_connect:VV
		\l_nsk_connect_arrow_style_tl
		\l_nsk_connect_color_tl
	}

	\group_end:
}


% ---------------------------------------------------------------------
% 6) Finalize: bridging arcs over/under
% ---------------------------------------------------------------------

% Expand each path vs. each other path, bridging accordingly.
\cs_new_protected_nopar:Npn \just_expand:VV #1#2
{
	\seq_map_inline:Nn #2
	{
		\iow_term:x {
			=inner => (#1, ##1)
			=style => \l_nsk_connect_bridging_style_tl
		}

		% local to each iteration
		\tl_set:Nx \a_tl {#1}
		\clist_set:No \args_dcs_clist {##1}
		\tl_set:Nx \b_tl {\clist_item:Nn \args_dcs_clist {1}}
		\tl_set:Nx \b_bridging_style_tl {\clist_item:Nn \args_dcs_clist {2}}

		\clist_show:N \args_dcs_clist
		\tl_show:N \b_bridging_style_tl

		% skip bridging with itself
		\tl_if_eq:NNF \a_tl \b_tl
		{
			\iow_term:x {
				difpaths: (\tl_use:N \a_tl, \tl_use:N \b_tl)
			}

			% bridging style => over or under
			\tl_if_eq:NNF \l_nsk_connect_bridging_style_tl \b_bridging_style_tl
			{

				\tl_if_eq:NnTF \l_nsk_connect_bridging_style_tl {over}
				{
					\exp_args:NNx \tl_set:Nn \brd_tl
					{ bridge={\tl_use:N \a_tl}{\tl_use:N \b_tl} }

				}
				{
					\exp_args:NNx \tl_set:Nn \brd_tl
					{ bridge={\tl_use:N \b_tl}{\tl_use:N \a_tl} }
				}

				\exp_args:Nx \tikzset{ \brd_tl }
			}


		}
	}
}


% A small init macro for bridging keys
\cs_new_protected_nopar:Npn \nsk__init_bridging_code:
{
\tikzset{
bridge/.style\space 2\space args={
spath/split\space at\space intersections\space with={##1}{##2},
spath/insert\space gaps\space after\space components={##1}{\pgfkeysvalueof{/tikz/bridging\space span}},
spath/join\space components\space upright\space with={##1}{\pgfkeysvalueof{/tikz/bridging\space path}},

spath/split\space at\space intersections\space with={##2}{##1},
spath/insert\space gaps\space after\space components={##2}{\pgfkeysvalueof{/tikz/bridging\space gap}},
},
}

\path[
	spath/save\space global=arc
]
(0,0)
arc[
		radius=1cm,
		start\space angle=180,
		delta\space angle=-180
	];
}


% ---------------------------------------------------------------------
% 7) Main Macro: \nskDoBridging
% ---------------------------------------------------------------------
\NewDocumentCommand \nskDoBridging { O{} }
{
	\group_begin:

	% Initialize bridging keys, and define an arc path globally
	\nsk__init_bridging_code:

	% For storing all path names
	\seq_new:N \l__nsk_tmp_paths_seq

	% Collect path names from bridging info
	\seq_map_inline:Nn \g__nsk_bridging_info_seq
	{
		% {pathid, bridging-style}
		\clist_set:Nn \l_tmpa_clist { ##1 }
		\exp_args:NNx \seq_put_right:No \l__nsk_tmp_paths_seq
		{ \clist_item:Nn \l_tmpa_clist {1}, \clist_item:Nn \l_tmpa_clist {4} }

		\seq_show:N \l__nsk_tmp_paths_seq
	}

	% Copy bridging info into a local seq, for iteration
	\seq_set_eq:NN \l__nsk_tmp_seq \g__nsk_bridging_info_seq


	% For each bridging path, set bridging keys, do bridging with others,
	% then finally draw its path.
	\seq_map_inline:Nn \l__nsk_tmp_seq
	{
		\clist_set:Nn \l_tmpa_clist { ##1 }

		\tl_set:Nx \l__nsk_pathname_tl
		{ \clist_item:Nn \l_tmpa_clist {1} }
		\tl_set:Nx \l__nsk_arrowstyle_tl
		{ \clist_item:Nn \l_tmpa_clist {2} }
		\tl_set:Nx \l__nsk_color_tl
		{ \clist_item:Nn \l_tmpa_clist {3} }

		\tl_set:Nx \l_nsk_connect_bridging_style_tl
		{ \clist_item:Nn \l_tmpa_clist {4} }

		\tl_set:Nx \l__nsk_bridgingpath_tl
		{ \clist_item:Nn \l_tmpa_clist {5} }
		\tl_set:Nx \l__nsk_bridgingspan_tl
		{ \clist_item:Nn \l_tmpa_clist {6} }
		\tl_set:Nx \l__nsk_bridginggap_tl
		{ \clist_item:Nn \l_tmpa_clist {7} }

		% Set bridging path, span, gap
		\tikzset{
			bridging\space path=\tl_use:N \l__nsk_bridgingpath_tl,
			bridging\space span=\tl_use:N \l__nsk_bridgingspan_tl,
			bridging\space gap=\tl_use:N \l__nsk_bridginggap_tl,
		}

		% do bridging over all other path names
		\just_expand:VV
		{\l__nsk_pathname_tl}
		{\l__nsk_tmp_paths_seq}

		\tl_show:N \l__nsk_arrowstyle_tl

		% finally draw the path with color
		\expandafter\draw\expandafter[
			\l__nsk_arrowstyle_tl,
			draw=\l__nsk_color_tl,
			spath/use=\l__nsk_pathname_tl
		];
	}

	% Clear bridging items so not redrawn
	\seq_clear:N \g__nsk_bridging_info_seq

	\group_end:
}

%-----------------------------------------------------------
% Route Bend
%-----------------------------------------------------------
\cs_new_protected_nopar:Npn \__nsk_parse_bend_route:n #1
{

	\seq_clear_new:N \l__nsk_tmp_seq
	% We assume #1 might be something like "up=1cm" or "down=2cm".
	\seq_set_split:Nnn \l__nsk_tmp_seq {=} { #1 }
	\seq_pop_left:NN \l__nsk_tmp_seq \l__nsk_tmp_tl % first token e.g. "up"
	% set direction
	\bool_set_true:N \l__nsk_connect_bend_bool
	\tl_set_eq:NN \l__nsk_connect_bend_direction_tl \l__nsk_tmp_tl
	% now the remainder is presumably the distance
	\seq_pop_left:NN \l__nsk_tmp_seq \l__nsk_tmp_tl
	\dim_set:Nn \l__nsk_connect_bend_amount_dim {\l__nsk_tmp_tl}
}

% This sets \l_nsk_connect_route_tl to the standard (– – distance -|) or (|- distance – –)
\cs_new_protected_nopar:Npn \__nsk_connect_generate_bend_route:
{
	\tl_clear_new:N \l_nsk_connect_route_tl

	% Copy bend-direction to a safe scratch var:
	\tl_set_eq:NN \l_tmpa_tl \l__nsk_connect_bend_direction_tl

	% Start building route
	\tl_set:Nn \l_nsk_connect_route_tl { -- ++(0, }

	% Now do a case on \l_tmpa_tl rather than raw \l__nsk_connect_bend_direction_tl
	\str_case:Vn { \l_tmpa_tl }
	{
		{up}
			{ \tl_put_right:No \l_nsk_connect_route_tl
				{ \dim_use:N \l__nsk_connect_bend_amount_dim ) -| } }
			{down}
			{ \tl_put_right:No \l_nsk_connect_route_tl
				{ -\dim_use:N \l__nsk_connect_bend_amount_dim ) -| } }
			{left}
			{
				\tl_set:Nn \l_nsk_connect_route_tl { -- ++( }
				\tl_put_right:No \l_nsk_connect_route_tl
				{ -\dim_use:N \l__nsk_connect_bend_amount_dim , 0 ) |- }
			}
			{right}
			{
				\tl_set:Nn \l_nsk_connect_route_tl { -- ++( }
				\tl_put_right:No \l_nsk_connect_route_tl
				{ \dim_use:N \l__nsk_connect_bend_amount_dim , 0 ) -| }
			}
	}
	{
		% fallback => treat as "up"
		\tl_put_right:No \l_nsk_connect_route_tl
		{ \dim_use:N \l__nsk_connect_bend_amount_dim ) -| }
	}
}

%-----------------------------------------------------------
% FillBetween
%-----------------------------------------------------------
\keys_define:nn { nsk / fillbetween }
{
	from .tl_set:N = \l_nsk_fillbetween_from_tl,
	from .value_required:n  = true,

	to   .tl_set:N = \l_nsk_fillbetween_to_tl,
	to   .value_required:n   = true,

	fill .tl_set:N = \l_nsk_fillbetween_fill_tl,
	fill .initial:n = {black!10},

	draw .tl_set:N = \l_nsk_fillbetween_draw_tl,
	draw .initial:n = {black!50},

	opacity .fp_set:N = \l_nsk_fillbetween_opacity_fp,
	opacity .initial:n = {0.3},

	edge .choice:,
	edge / straight .code:n = { \tl_set:Nn \l_nsk_fillbetween_edge_tl { straight } },
	edge / curved  .code:n  = { \tl_set:Nn \l_nsk_fillbetween_edge_tl { curved } },
	edge .initial:n = {straight},

	orientation .choice:,
	orientation / vertical   .code:n = { \tl_set:Nn \l_nsk_fillbetween_orient_tl { vertical } },
	orientation / horizontal .code:n = { \tl_set:Nn \l_nsk_fillbetween_orient_tl { horizontal } },
	orientation .initial:n   = { vertical },

	% If you want an explicit “out=xx, in=yy” override, you could add:
	out .tl_set:N = \l_nsk_fillbetween_out_tl,
	out .initial:n = {},

	in .tl_set:N  = \l_nsk_fillbetween_in_tl,
	in .initial:n = {},

	corner-offset .dim_set:N = \l_nsk_fillbetween_corner_offset_dim,
	corner-offset .initial:n = {0pt},
	corner-offset .default:n = {0pt},

}

%=================================================================
%  B) Internal Drawing Helper
%=================================================================
\dim_new:N \l__nsk_offset_west_dim
\dim_new:N \l__nsk_offset_east_dim
\dim_new:N \l__nsk_offset_north_dim
\dim_new:N \l__nsk_offset_south_dim

\cs_new_protected_nopar:Npn \__nsk_fillbetween_draw:
{

	% 2) Prepare local shift offsets for each corner direction:
	%    By default, do no shift.
	\dim_set:Nn \l__nsk_offset_west_dim  { 0pt }
	\dim_set:Nn \l__nsk_offset_east_dim  { 0pt }
	\dim_set:Nn \l__nsk_offset_north_dim { 0pt }
	\dim_set:Nn \l__nsk_offset_south_dim { 0pt }

	% If orientation=vertical
	\str_if_eq:VnT { \l_nsk_fillbetween_orient_tl } { vertical }
	{
		\dim_set:Nn    \l__nsk_offset_south_dim { \dim_use:N \l_nsk_fillbetween_corner_offset_dim }
		\dim_set:Nn    \l__nsk_offset_north_dim { -\dim_use:N \l_nsk_fillbetween_corner_offset_dim }
	}

	% If orientation=horizontal
	\str_if_eq:VnT { \l_nsk_fillbetween_orient_tl } { horizontal }
	{
		\dim_set_eq:NN \l__nsk_offset_west_dim  \l_nsk_fillbetween_corner_offset_dim
		\dim_set:Nn    \l__nsk_offset_east_dim { -\dim_use:N \l_nsk_fillbetween_corner_offset_dim }
	}
	% 1) Determine out/in angles if user wants curved edges but didn't provide them
	\tl_if_eq:NNF \l_nsk_fillbetween_edge_tl \c_tl_empty_tl
	{
		\tl_if_eq:NnT \l_nsk_fillbetween_edge_tl {curved}
		{
			% if "curved" but user didn't specify \l_nsk_fillbetween_out_tl or in_tl
			% we can set them based on orientation
			\tl_if_blank:VTF \l_nsk_fillbetween_out_tl
			{
				\str_case:Vn { \l_nsk_fillbetween_orient_tl }
				{
					{vertical}   { \tl_set:Nn \l_nsk_fillbetween_out_tl { 90 } }
						{horizontal} { \tl_set:Nn \l_nsk_fillbetween_out_tl {   180 } }
				}{}
			}{}

			\tl_if_blank:VTF \l_nsk_fillbetween_in_tl
			{
				\str_case:Vn { \l_nsk_fillbetween_orient_tl }
				{
					{vertical}   { \tl_set:Nn \l_nsk_fillbetween_in_tl  { -90 } }
						{horizontal} { \tl_set:Nn \l_nsk_fillbetween_in_tl  { 0 } }
				}{}
			}{}
		}
	}
	\begin{pgfonlayer}{interim}
		\draw[
			fill=\l_nsk_fillbetween_fill_tl,
			draw=\l_nsk_fillbetween_draw_tl,
			opacity=\fp_use:N \l_nsk_fillbetween_opacity_fp
		]
		let
		% -- “From” corners --
		\p{TL_a} = ($(\l_nsk_fillbetween_from_tl.north\space west)
			+ (\dim_use:N \l__nsk_offset_west_dim,
			\dim_use:N \l__nsk_offset_north_dim)$),

		\p{TR_a} = ($(\l_nsk_fillbetween_from_tl.north\space east)
			+ (\dim_use:N \l__nsk_offset_east_dim,
			\dim_use:N \l__nsk_offset_north_dim)$),

		\p{BL_a} = ($(\l_nsk_fillbetween_from_tl.south\space west)
			+ (\dim_use:N \l__nsk_offset_west_dim,
			\dim_use:N \l__nsk_offset_south_dim)$),

		\p{BR_a} = ($(\l_nsk_fillbetween_from_tl.south\space east)
			+ (\dim_use:N \l__nsk_offset_east_dim,
			\dim_use:N \l__nsk_offset_south_dim)$),

		% -- “To” corners --
		\p{TL_b} = ($(\l_nsk_fillbetween_to_tl.north\space west)
			+ (\dim_use:N \l__nsk_offset_west_dim,
			\dim_use:N \l__nsk_offset_north_dim)$),

		\p{TR_b} = ($(\l_nsk_fillbetween_to_tl.north\space east)
			+ (\dim_use:N \l__nsk_offset_east_dim,
			\dim_use:N \l__nsk_offset_north_dim)$),

		\p{BL_b} = ($(\l_nsk_fillbetween_to_tl.south\space west)
			+ (\dim_use:N \l__nsk_offset_west_dim,
			\dim_use:N \l__nsk_offset_south_dim)$),

		\p{BR_b} = ($(\l_nsk_fillbetween_to_tl.south\space east)
			+ (\dim_use:N \l__nsk_offset_east_dim,
			\dim_use:N \l__nsk_offset_south_dim)$)
		in
		\str_case:VnF { \l_nsk_fillbetween_edge_tl }
		{
			{straight}
				{
					\str_case:Vn { \l_nsk_fillbetween_orient_tl }
					{
						{vertical}   {
								(\p{BL_a}) -- (\p{TL_b}) -- (\p{TR_b}) -- (\p{BR_a})
								-- cycle;
							}
							{horizontal} {
								(\p{TR_a}) -- (\p{TL_b}) -- (\p{BL_b}) -- (\p{BR_a})
								-- cycle;
							}
					}{}
				}
				{curved}
				{
					\str_case:Vn { \l_nsk_fillbetween_orient_tl }
					{
						{vertical}   {
								(\p{BL_a}) to[out=\tl_use:N \l_nsk_fillbetween_in_tl, in=\tl_use:N \l_nsk_fillbetween_out_tl] (\p{TL_b})
								-- (\p{TR_b}) to[out=\tl_use:N \l_nsk_fillbetween_out_tl, in=\tl_use:N \l_nsk_fillbetween_in_tl] (\p{BR_a})
								-- cycle;
							}
							{horizontal} {
								(\p{TR_a}) to[out=\tl_use:N \l_nsk_fillbetween_in_tl, in=\tl_use:N \l_nsk_fillbetween_out_tl] (\p{TL_b})
								-- (\p{BL_b}) to[out=\tl_use:N \l_nsk_fillbetween_out_tl, in=\tl_use:N \l_nsk_fillbetween_in_tl] (\p{BR_a})
								-- cycle;
							}
					}{}
				}
		}
		{
			% (\p{BL_a}) -- (\p{TL_b}) -- (\p{TR_b}) -- (\p{BR_a})
			% -- cycle;
		}
	\end{pgfonlayer}
}

%=================================================================
%  C) Public Macro: \nskFillBetween
%=================================================================
\NewDocumentCommand \nskFillBetween { O{} }
{
	\group_begin:
	% 1. Parse the keys
	\keys_set:nn {nsk / fillbetween}{#1}

	% 2. Draw
	\__nsk_fillbetween_draw:
	\group_end:
}


\ExplSyntaxOff
