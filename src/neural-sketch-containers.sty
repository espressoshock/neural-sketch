\ExplSyntaxOn
%---------------------------------------------
% 1) Minimal: We'll define "container" keys,
%    but basically we just forward them to nskGroup keys.
%---------------------------------------------

% 1) Declare your custom layers
\pgfdeclarelayer{background}
\pgfdeclarelayer{interim}
\pgfdeclarelayer{foreground}

% 2) Set the order in which layers are drawn
%    (lowest -> highest)
\pgfsetlayers{background,interim,main,foreground}


\prop_new:N \l_nsk_container_unknown_prop

\cs_new_protected_nopar:Npn \nsk__container_parse_pos_value:nn #1#2
{
  % #1 = the user’s "right=1cm of X" or "above=2mm of Y" ...
  % #2 = the container’s padding dimension (e.g. 3mm)

  % 1) Save the *raw* pos string to \l_nsk_container_pos_tl
  \tl_set:Nx \l_nsk_container_pos_tl {#1}

  % 2) Split at '=' (only if the user wrote e.g. "right=1cm of X").
  \seq_set_split:Nnn \l_tmpa_seq {=}{#1}
  \seq_show:N \l_tmpa_seq

  % 3) If we have exactly 2 items, item 1 is "right" and item 2 is "1cm of X".
  \int_compare:nNnT { \seq_count:N \l_tmpa_seq } = {2}
  {
    % The direction (left/right/above/below)
    \tl_set:Nx \l_tmpa_tl { \seq_item:Nn \l_tmpa_seq {1} }
    \tl_trim_spaces:N \l_tmpa_tl

    % The distance+node portion
    \tl_set:Nx \l_tmpb_tl { \seq_item:Nn \l_tmpa_seq {2} }
    \tl_trim_spaces:N \l_tmpb_tl

    \tl_show:N \l_tmpa_tl
    \tl_show:N \l_tmpb_tl

     % We'll try to split at " of "
    \seq_set_split:Nnx \l_tmpb_seq {of}{\l_tmpb_tl}
    \seq_show:N \l_tmpb_seq


    \int_compare:nNnT { \seq_count:N \l_tmpb_seq } = {2}
    {
      % item 1 = "1cm", item 2 = "X"
      \tl_set:Nx \l_tmpc_tl { \seq_item:Nn \l_tmpb_seq {1} }
      \tl_trim_spaces:N \l_tmpc_tl
      \tl_set:Nx \l_tmpd_tl { \seq_item:Nn \l_tmpb_seq {2} }
      \tl_trim_spaces:N \l_tmpd_tl
      \tl_show:N \l_tmpc_tl
      \tl_show:N \l_tmpd_tl


      % Convert "1cm" to a dimension variable
      \dim_new:N \l__nsk_tmp_dim
      \dim_set:Nn \l__nsk_tmp_dim {\tl_use:N \l_tmpc_tl}
      \dim_show:N \l__nsk_tmp_dim
      % Now add the container's padding
      \dim_add:Nn \l__nsk_tmp_dim  { #2 }
      \dim_show:N \l__nsk_tmp_dim


      % Rebuild "right=(dist+pad) of X"
      \tl_set:Nx \l_nsk_container_pos_tl
      {
        \tl_use:N \l_tmpa_tl
        = \dim_use:N \l__nsk_tmp_dim
        \c_space_tl of \c_space_tl
        \tl_use:N \l_tmpd_tl
      }
    }
  }

}


\keys_define:nn {nsk / container}
{
	% ref-id ---------------------------------------------------
	% todo: passed through
	id .tl_set:N = \l_nsk_block_id_tl,
	id .initial:n = { },

	% Let the user specify fill, border-type, border-color if desired
	border-type .choice:,
	border-type / solid .code:n = \tl_set:Nn \l_nsk_container_border_type_tl { solid },
	border-type / dashed .code:n = \tl_set:Nn \l_nsk_container_border_type_tl { dashed },
	border-type .initial:n = { dashed },
	border-type .default:n = { dashed },

	border-color .tl_set:N = \l_nsk_container_border_color_tl,
	border-color .initial:V = \g__nsk_style_container_border_color_tl,
	border-color .default:V = \g__nsk_style_container_border_color_tl,

	fill .tl_set:N = \l_nsk_container_fill_tl,
	fill .initial:V = \g__nsk_style_container_fill_tl,
	fill .default:V = \g__nsk_style_container_fill_tl,

	padding .dim_set:N = \l_nsk_container_padding_tl,
	padding .initial:V = \g__nsk_style_container_padding_dim,
	padding .default:V = \g__nsk_style_container_padding_dim,

	shift-x .fp_set:N = \l_nsk_container_x_fp,
	shift-x .initial:V = \g__nsk_style_container_x_fp,
	shift-x .default:V = \g__nsk_style_container_x_fp,

	shift-y .fp_set:N = \l_nsk_container_y_fp,
	shift-y .initial:V = \g__nsk_style_container_y_fp,
	shift-y .default:V = \g__nsk_style_container_y_fp,

	% natural positioning using positioning library
	pos .code:n =
		{
			\nsk__container_parse_pos_value:nn {#1} {\l_nsk_container_padding_tl}
		},
	pos .initial:n = { },
	pos .default:n = { },

	rotate .fp_set:N = \l_nsk_container_rotate_fp,
	rotate .initial:V = \g__nsk_style_container_rotate_fp,
	rotate .default:V = \g__nsk_style_container_rotate_fp,

	scale .fp_set:N = \l_nsk_container_scale_fp,
	scale .initial:V = \g__nsk_style_container_scale_fp,
	scale .default:V = \g__nsk_style_container_scale_fp,

	% forward unknown props to nsblocks
	unknown .code:n =
		{
			% Store unknown key in the property list, using the content of \l_keys_key_tl as a string
			\prop_put:Nxx \l_nsk_container_unknown_prop
			{ \tl_use:N \l_keys_key_tl }
			{ #1 }
		},

}



%---------------------------------------------
% 2) \nskContainer macro
%---------------------------------------------
\NewDocumentCommand \nskContainer { O{} +m }
{
	\group_begin:

	% (a) Clear the property list so it doesn't retain any old unknown keys
	% \prop_clear_new:N \l_nsk_container_unknown_prop

	% (b) Parse recognized container keys + store unknown keys
	\keys_set:nn {nsk / container}{#1}

	% (c) Now call \nskGroup, passing the same #1 so that shift-x, rotate, etc.
	%     get recognized by nsk / group (or remain unknown for that domain).
	\nskGroup[
		shift-x=\fp_use:N \l_nsk_container_x_fp,
		shift-y=\fp_use:N \l_nsk_container_y_fp,
		rotate=\fp_use:N \l_nsk_container_rotate_fp,
		scale=\fp_use:N \l_nsk_container_scale_fp,
		pos=\tl_use:N \l_nsk_container_pos_tl,
	]
	{
		% user content
		#2
	}

	% (d) Build an \nskBlock that fits the bounding box, plus any unknown keys
	%     stored in \l_nsk_container_unknown_prop. We'll do a small helper:
	\nsk__container_draw_block:

	\group_end:
}

% block expander -------------------------------------------
\cs_new_protected_nopar:Npn \nsk__expand_block_aux:n #1
{

	\begin{pgfonlayer}{background}
		\nskBlock [
			% this are computed by bounding box
			width=0pt, height=0pt,
			shadow=false,
			text-north=\nskBlockID,
			#1,
		]
	\end{pgfonlayer}
}

% Generate a "V V V V" variant so that we can pass token-list
% variables or dimension variables by *value*.
\cs_generate_variant:Nn \nsk__expand_block_aux:n { V }


% Generate a "V V V V" variant so that we can pass token-list
% variables or dimension variables by *value*.
\cs_generate_variant:Nn \nskBlockFromList:V { V }

\cs_new_protected_nopar:Npn \nsk__container_draw_block:
{
% We'll build a token list of block options
\tl_clear_new:N \l_tmpa_tl

% put recognized container keys:
\tl_put_right:No \l_tmpa_tl { type=rectangle, }
\tl_put_right:No \l_tmpa_tl { fill=\l_nsk_container_fill_tl, }
\tl_put_right:No \l_tmpa_tl { border-color=\l_nsk_container_border_color_tl, }
% use tikz-ops keys
\tl_put_right:No \l_tmpa_tl
{ tikz-opts={fit=(\l_nsk_group_bounds_name_tl), inner\space sep=\l_nsk_container_padding_tl,
			\l_nsk_container_border_type_tl}, }


% forward unknown keys as-is
\prop_map_inline:Nn \l_nsk_container_unknown_prop
{
	\tl_put_right:Nn \l_tmpa_tl
	{
		{##1} = {##2},
			}
	}

	\nsk__expand_block_aux:V \l_tmpa_tl
}

\ExplSyntaxOff
